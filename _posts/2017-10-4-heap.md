---
layout: post
title: Binary Min Heap (Interview Practice)
headline: In preparation for upcoming interviews, I've decided to write a series of posts dedicated to the fundamental 
            data structures and algorithms. My hope is to practice documenting and explaining my thought process. First up, the classic
            binary min heap.
---

Interviews are coming up, and while I feel pretty prepared in terms of the
technical information I know, I figured it would be good practice to document and explain 
my thought process. I've chosen Python because it's quick -- not the quickest language out there of course,
but one of the quickest in terms of creating sketches and getting ideas out there. Also, my experience is in Java, so
this post will also be an exercise to help me improve my fluency in Python. Today I'll be writing a basic
binary min heap.

The idea is to create a binary tree with the heap property. In the case of a binary min heap,
this means that every parent node must be smaller than or equal to its children
We start by building the class declaration and constructor. We'll be representing the binary min heap
as a list, and to make our lives easier, we'll be ignoring the 0th element of the list. By effectively starting our list
at index 1, the children of a node indexed at *i* would be *i * 2* and *i * 2 + 1*

{% highlight python %}
class BinMinHeap:
    def __init__(self):
        self.heap_list = [0] # ignore the first guy
        self.size = 0     
{% endhighlight %}

Now, we need a way to insert into this binary min heap. One way to do this is to always append to the list that represents the 
binary min heap. This way, we can preserve as much of the heap property as possible. In the case that appending to the list 
ruins the heap property, we can make adjustments as appropriate. This process is called bubbling up, since if the element we add
is smaller than its parent, then we must swap them -- the element gets bubbled up.

{% highlight python %}
# i -- the index at which the inserted element is located
def bubble_up(self, i):
    parent = i // 2
    while parent > 0:
        
        # bubble up if smaller than parent
        if self.heap_list[i] < self.heap_list[parent]: 
            tmp = self.heap_list[i // 2]
            self.heap_list[parent] = self.heap_list[i]
            self.heap_list[i] = tmp
        i /= 2

# just a recursive equivalent of the above       
def bubble_up_recursive(self, i):
    parent = i // 2
    if parent == 0:
        return
    elif self.heap_list[parent] <= self.heap_list[i]:
        return
    else:
        tmp = self.heap_list[i // 2]
        self.heap_list[parent] = self.heap_list[i]
        self.heap_list[i] = tmp
        bubble_up_recursive(self, parent)
    
# k -- the element we want to insert into the heap
def insert(self, k):
    self.heap_list.append(k) # add to end
    self.size += 1
    bubble_up(self.size)
        
{% endhighlight %}

Another useful operation would be to remove the root (1st element). We could do
that by swapping out the last element in the list with the first one, and bubbling down

{% highlight python %}
# i -- the index of the root 
def bubble_down(self, i):
    while (i * 2) <= self.size:
        min = self.min_child(i)
        if self.heap_list[i] > self.heap_list[min]:
            tmp = self.heap_list[i]
            self.heap_list[i] = self.heap_list[min]
            self.heap_list[min] = tmp
        i = min

# gets the smaller child of the node at i
def min_child(self, i):
    if i * 2 + 1> self.size:
        return i * 2
    else:
        if self.heap_list[i * 2] < self.heap_list[i * 2 + 1]:
            return i * 2
        else:
            return i * 2 + 1
            
# deletes the root (min)
def del_min(self):
    ret = self.heap_list[1]
    self.heap_list[1] = self.heap_list[self.size]
    self.size -= 1
    self.heap_list.pop()
    self.bubble_down(1)
    return ret
{% endhighlight %}


Now it might be useful to get or remove a specific node too:

{% highlight python %}

# reuse some code from del_min
# we could be neat and wrap everything in the same function
# deletes the root at index i
def del_index(self, i):
    ret = self.heap_list[i]
    self.heap_list[i] = self.heap_list[self.size]
    self.size -= 1
    self.heap_list.pop()
    self.bubble_down(i)
    return ret

# deletes a specific node with value k, if it exists
# k -- value we want to delete
# i -- index we are currently exploring
def del_node(self, k, i):
    if self.heap_list[i] > k:
        return # can't find it
    elif self.heap_list[i] == k:
        ret = self.heap_list[i]
        del_index(i)
        return ret
    else:
        a = del_node(k, i // 2) # explore left
        b = del_node(k, i // 2 + 1) # explore right
        return a if a else b # return the one that we found
{% endhighlight %}

Thought it might not be very helpful to be returning the number we just deleted, since
we are operating with a heap of integers, imagine if we were heapifying with keys or hashcodes
That'd be more helpful, and in hindsight, it would have been fun to build that as well for this post.